<!DOCTYPE html>
<html lang="en-US">

<head>
    <title>Script Editor</title>
    <meta charset="UTF-8">
    <script>
        const functions = {
            "sendMessage": [['sendMessage("CARET", "")'], ['sendMessage(channelId, content)']],
            "deleteMessage": [['deleteMessage("CARET")'], ['deleteMessage(messageId)']],
            "kick": [['kick("CARET", "")', 'kick("CARET")'], ['kick(userId, reason)', 'kick(userId)']],
            "ban": [['ban("CARET", "")', 'ban("CARET")'], ['ban(userId, reason)', 'ban(userId)']]
        };
        const returnOnlyFunctions = {
            "startsWith": [['startsWith("CARET", "")'], ['startsWith(text, with)']],
            "endsWith": [['endsWith("CARET", "")'], ['endsWith(text, with)']]
        };
        var eventBasedVariables = [];
        var completions = {};
        var caretHeight;
        var highl = false;

        updateCompletions = (ta) => {
            completions = {};
            let caretPos = $(ta).prop("selectionStart");
            if ($(ta).prop("selectionEnd") != caretPos) {
                let ca = document.getElementById("completions");
                if (ca) ca.outerHTML = "";
                return;
            }
            let rowsBefore = ta.value.substr(0, caretPos).split("\n");
            rowsBefore.pop();
            let rowNumber = rowsBefore.length;
            let rowValue = ta.value.split("\n")[rowNumber];
            let col = caretPos - rowsBefore.join("\n").length - (rowNumber == 0 ? 0 : 1);
            let variables = [].concat(eventBasedVariables);
            for (let row of rowsBefore) {
                let varName = row.match(/^ *[a-zA-Z]+ *(?=\=)/);
                if (!varName) continue;
                variables.push(varName[0].trim());
            }
            let rowValueToCaret = rowValue.substr(0, col);
            if (!rowValueToCaret.includes("(")) {
                // outside the function
                let functionName = rowValueToCaret.substring(rowValueToCaret.indexOf("=") + 1, rowValueToCaret.length).trim();
                let functionNameSelected = col > rowValue.indexOf("=");
                if (functionNameSelected) {
                    let funcs = Object.assign(Object.assign({}, functions), rowValueToCaret.includes("=") ? returnOnlyFunctions : {});
                    for (let funcName in funcs) {
                        if (funcName.trim().startsWith(functionName)) {
                            completions[funcName] = [funcs[funcName][0].map(x => x.substr(functionName.length)), funcs[funcName][1]];
                        }
                    }
                }
            } else {
                // inside the function
                let currVarName = rowValueToCaret.match(/%[a-zA-Z]*$/);
                if (currVarName) {
                    currVarName = currVarName[0].substr(1);
                    let valueBefore = rowValueToCaret.substr(0, rowValueToCaret.length - currVarName.length);
                    let complete = true;
                    for (let variable of variables) {
                        if (valueBefore.endsWith(`%${variable}%`)) complete = false;
                    }
                    if (complete) {
                        for (let variable of variables) {
                            if (variable.startsWith(currVarName)) {
                                completions[variable] = [[`${variable.substr(currVarName.length)}%CARET`], [variable]];
                            }
                        }
                    }
                }
            }
            let completionArea = document.getElementById("completions");
            if (completionArea) completionArea.innerHTML = "";
            else completionArea = $(`<div id="completions"></div>`)[0];
            document.body.appendChild(completionArea);
            for (let completion in completions) {
                let el = $(`<div function-variation="0"></div>`);
                el[0].updateFunction = function(cnt){
                    let funcCount = Object.keys(completions[completion][1]).length;
                    let newIndex = (cnt + funcCount + getVariation(this)) % funcCount;
                    el.attr("function-variation", newIndex);
                    this.innerHTML = "";
                    let aComplete = $(`<span class="completeSuggestion"></span>`).appendTo(this);
                    aComplete[0].innerText = completions[completion][1][newIndex];
                    aComplete.on("click", ()=>{
                        ta.value = ta.value.substr(0, caretPos) + completions[completion][0][getVariation(el[0])].replace("CARET", "") + ta.value.substring(caretPos, ta.value.length);
                        ta.selectionEnd = caretPos + completions[completion][0][getVariation(el[0])].indexOf("CARET");
                        ta.focus();
                    });
                    if(funcCount > 1){
                        let aRight = $(`<span class="completeRight">&gt;</span>`).appendTo(this);
                        let aLeft = $(`<span class="completeLeft">&lt;</span>`).appendTo(this);
                        aLeft.on("click", ()=>{this.updateFunction(-1)});
                        aRight.on("click", ()=>{this.updateFunction(1)});
                    }
                };
                el[0].updateFunction(0);
                el.on("mousedown", () => {
                    removeCompletions = new Date().getTime();
                });
                el.appendTo(completionArea);
            }
            if (Object.keys(completions).length == 0) completionArea.outerHTML = "";
            updateCompletionsPos(ta, caretPos, completionArea);
        }
        var removeCompletions = new Date().getTime();

        getVariation = (el) => {
            return parseInt($(el).attr("function-variation"));
        }

        updateCompletionsPos = (ta, caretPos, completionArea) => {
            if (!completionArea) return;
            if (!caretPos) caretPos = $(ta).prop("selectionStart");
            let carPos = getCaretCoordinates(ta, caretPos);
            let arePos = ta.getBoundingClientRect();
            $(completionArea).css({ "left": (carPos.left + arePos.left) + "px", "top": (carPos.top + arePos.top - ta.scrollTop + caretHeight + 5) + "px" });
        }

        updateSelectedCompletion = (cnt) => {
            let ca = document.getElementById("completions");
            if (!ca) return;
            let sel = ca.getElementsByClassName("selected")[0];
            if (!sel) {
                sel = ca.firstElementChild;
                sel.classList.add("selected");
                if (cnt > 0) cnt--;
            }
            if (cnt < 0) {
                let newSel = sel;
                while (cnt < 0) {
                    cnt++;
                    newSel = newSel.previousElementSibling;
                    if (!newSel) newSel = ca.lastElementChild;
                }
                sel.classList.remove("selected");
                newSel.classList.add("selected");
                sel = newSel;
            } else if (cnt > 0) {
                let newSel = sel;
                while (cnt > 0) {
                    cnt--;
                    newSel = newSel.nextElementSibling;
                    if (!newSel) newSel = ca.firstElementChild;
                }
                sel.classList.remove("selected");
                newSel.classList.add("selected");
                sel = newSel;
            }
            ca.scrollTop = sel.offsetTop - 30;
        }

        applyHighlighting = (ta) => {
            if(!highl) return;
            let text = ta.value;
            let variables = [].concat(eventBasedVariables);
            let highlighted = escapeHtml(text).split("\n").map(line => {
                let retLine = "";
                let varDef = line.match(/^( *)([a-zA-Z]+)( *)=/);
                let varsNew = [];
                if(varDef){
                    varsNew.push(varDef[2]);
                    retLine += varDef[1] + `<mark class="highlightVariableDeclaration">${varDef[2]}</mark>` + varDef[3] + `<mark class="highlightVariableAssignment">=</mark>`;
                    line = line.substr(varDef[0].length);
                }
                let funcName = line.match(/^( *)([a-zA-Z]+)( *)\((.*)\)( *)$/);
                if(funcName){
                    let funcArgs = funcName[4].replace(/&quot;/g, '"');
                    let argMatch = funcArgs.match(/^( *)"(.*)"( *),( *)"(.*)"( *),( *)"(.*)"( *)$/);
                    if(!argMatch) argMatch = funcArgs.match(/^( *)"(.*)"( *),( *)"(.*)"( *)$/);
                    if(!argMatch) argMatch = funcArgs.match(/^( *)"(.*)"( *)$/);
                    if(!argMatch) argMatch = funcArgs.match(/^( *)$/);
                    if(argMatch){
                        funcArgs = "";
                        for(let i = 1; i < argMatch.length; i+=3){
                            let argInner = argMatch[i+1];
                            argInner = argInner.replace(new RegExp(`%(${variables.map(v => escapeRegex(v)).join("|")})%`, "g"), `<mark class="highlightVariableMark">%</mark><mark class="highlightVariableName">$1</mark><mark class="highlightVariableMark">%</mark>`);
                            funcArgs += argMatch[i] + `<mark class="highlightFunctionQuot">&quot;</mark>` + `<mark class="highlightFunctionArgument">${argInner}</mark>` + `<mark class="highlightFunctionQuot">&quot;</mark>` + argMatch[i+2];
                            if(i < argMatch.length) funcArgs += `<mark class="highlightFunctionComma">,</mark>`;
                        }
                    }
                    retLine += funcName[1] + `<mark class="highlightFunctionName">${funcName[2]}</mark>` + funcName[3] + `<mark class="highlightParentheseOpen">(</mark>` + `<mark class="highlightFunctionArguments">${funcArgs}</mark>` + `<mark class="highlightParentheseClose">)</mark>` + funcName[5];
                    line = line.substr(funcName[0].length);
                }
                variables.push(varsNew);
                return retLine;
            }).join("\n").replace(/\n/g, '<br>');
            $("#highlights").html(highlighted);
        }

        init = () => {
            $(document).ready(() => {
                $("#scriptarea").on("keyup click focus", function (e) {
                    if (e.type == "keyup" && document.getElementById("completions") && (e.which == 38 || e.which == 40)) return;
                    if(e.type == "keyup" && $(".selected .completeLeft").length > 0 && (e.which == 37 || e.which == 39)) return;
                    if(e.type == "keyup" && e.which == 27) return;
                    updateCompletions(this);
                });
                $("#scriptarea").on("scroll resize", function (e) {
                    updateCompletionsPos(this, null, document.getElementById("completions"));
                });
                $("#scriptarea").on("blur", function (e) {
                    window.setTimeout(() => {
                        if (new Date().getTime() - removeCompletions < 10) return;
                        let completionArea = document.getElementById("completions");
                        if (completionArea) completionArea.outerHTML = "";
                    }, 1);
                });
                $("#scriptarea").on("keydown", function (e) {
                    if (Object.keys(completions).length > 0) {
                        if (e.which == 13) {
                            let ta = document.getElementById("scriptarea");
                            let caretPos = $(ta).prop("selectionStart");
                            let rowsBefore = ta.value.substr(0, caretPos).split("\n");
                            rowsBefore.pop();
                            let rowNumber = rowsBefore.length;
                            let rowValue = ta.value.split("\n")[rowNumber];
                            let col = caretPos - rowsBefore.join("\n").length - (rowNumber == 0 ? 0 : 1);
                            let rowValueToCaret = rowValue.substr(0, col);
                            if (!rowValueToCaret.includes("(")) {
                                // outside the function
                                let functionName = rowValueToCaret.substring(rowValueToCaret.indexOf("=") + 1, rowValueToCaret.length).trim();
                                let functionNameSelected = col > rowValue.indexOf("=");
                                if (functionNameSelected) {
                                    if (functionName.length == 0 && document.getElementsByClassName("selected").length == 0) return;
                                }
                            }
                            updateSelectedCompletion(0);
                            $(".selected .completeSuggestion").click();
                            e.preventDefault();
                        }else if(e.which == 9){
                            updateSelectedCompletion(0);
                            $(".selected .completeSuggestion").click();
                            e.preventDefault();
                        } else if (e.which == 40 && document.getElementById("completions")) {
                            updateSelectedCompletion(1);
                            e.preventDefault();
                        } else if (e.which == 38 && document.getElementById("completions")) {
                            updateSelectedCompletion(-1);
                            e.preventDefault();
                        } else if(e.which == 37 && $(".selected .completeLeft").length > 0) {
                            document.getElementsByClassName("selected")[0].updateFunction(-1);
                            e.preventDefault();
                        } else if(e.which == 39 && $(".selected .completeLeft").length > 0){
                            document.getElementsByClassName("selected")[0].updateFunction(1);
                            e.preventDefault();
                        }else if(e.which == 27){
                            let ca = document.getElementById("completions");
                            if(ca) ca.outerHTML = "";
                        }
                    }
                });

                $("#scriptarea").on("scroll", function(e){
                    let scrollTop = $(this).scrollTop();
                    $("#backdrop").scrollTop(scrollTop);
                });
                $("#scriptarea").on("input propertychange change paste", function(e){
                    applyHighlighting(this);
                });
                
                // SOURCE: https://github.com/component/textarea-caret-position
                (function () {/* We'll copy the properties below into the mirror div. Note that some browsers, such as Firefox, do not concatenate properties into their shorthand (e.g. padding-top, padding-bottom etc. -> padding), so we have to list every single property explicitly.*/var properties = ['direction',  /* RTL support*/'boxSizing','width',  /* on Chrome and IE, exclude the scrollbar, so the mirror div wraps exactly as the textarea does*/'height','overflowX','overflowY',/* copy the scrollbar for IE*/
                'borderTopWidth','borderRightWidth','borderBottomWidth','borderLeftWidth','borderStyle','paddingTop','paddingRight','paddingBottom','paddingLeft',/* https://developer.mozilla.org/en-US/docs/Web/CSS/font*/'fontStyle','fontVariant','fontWeight','fontStretch','fontSize','fontSizeAdjust','lineHeight','fontFamily','textAlign','textTransform','textIndent','textDecoration',  /* might not make a difference, but better be safe*/'letterSpacing','wordSpacing','tabSize','MozTabSize'];
                var isBrowser = (typeof window !== 'undefined');var isFirefox = (isBrowser && window.mozInnerScreenX != null);function getCaretCoordinates(element, position, options) {if (!isBrowser) {throw new Error('textarea-caret-position#getCaretCoordinates should only be called in a browser');}var debug = options && options.debug || false;if (debug) {var el = document.querySelector('#input-textarea-caret-position-mirror-div');if (el) el.parentNode.removeChild(el);}/* The mirror div will replicate the textarea's style*/
                var div = document.createElement('div');div.id = 'input-textarea-caret-position-mirror-div';document.body.appendChild(div);var style = div.style;var computed = window.getComputedStyle ? window.getComputedStyle(element) : element.currentStyle;  /* currentStyle for IE < 9*/var isInput = element.nodeName === 'INPUT';/* Default textarea styles*/style.whiteSpace = 'pre-wrap';if (!isInput)style.wordWrap = 'break-word';  /* only for textarea-s*//* Position off-screen*/
                style.position = 'absolute';  /* required to return coordinates properly*/if (!debug)style.visibility = 'hidden';  /* not 'display: none' because we want rendering*//* Transfer the element's properties to the div*/properties.forEach(function (prop) {if (isInput && prop === 'lineHeight') {/* Special case for <input>s because text is rendered centered and line height may be != height*/if (computed.boxSizing === "border-box") {var height = parseInt(computed.height);
                var outerHeight =parseInt(computed.paddingTop) +parseInt(computed.paddingBottom) +parseInt(computed.borderTopWidth) +parseInt(computed.borderBottomWidth);var targetHeight = outerHeight + parseInt(computed.lineHeight);if (height > targetHeight) {style.lineHeight = height - outerHeight + "px";} else if (height === targetHeight) {style.lineHeight = computed.lineHeight;} else {style.lineHeight = 0;}} else {style.lineHeight = computed.height;}} else {style[prop] = computed[prop];}});if (isFirefox) 
                {/* Firefox lies about the overflow property for textareas: https://bugzilla.mozilla.org/show_bug.cgi?id=984275*/if (element.scrollHeight > parseInt(computed.height))style.overflowY = 'scroll';} else {style.overflow = 'hidden';  /* for Chrome to not render a scrollbar; IE keeps overflowY = 'scroll'*/}div.textContent = element.value.substring(0, position);/* The second special handling for input type="text" vs textarea: spaces need to be replaced with non-breaking spaces - http://stackoverflow.com/a/13402035/1269037*/
                if (isInput)div.textContent = div.textContent.replace(/\s/g, '\u00a0');var span = document.createElement('span');/* Wrapping must be replicated *exactly*, including when a long word gets onto the next line, with whitespace at the end of the line before (#7). The  *only* reliable way to do that is to copy the *entire* rest of the textarea's content into the <span> created at the caret position. For inputs, just '.' would be enough, but no need to bother.*/
                span.textContent = element.value.substring(position) || '.';  /* || because a completely empty faux span doesn't render at all*/div.appendChild(span);var coordinates = {top: span.offsetTop + parseInt(computed['borderTopWidth']),left: span.offsetLeft + parseInt(computed['borderLeftWidth']),height: parseInt(computed['lineHeight'])};if (debug) {span.style.backgroundColor = '#aaa';} else {document.body.removeChild(div);}return coordinates;}if (typeof module != 'undefined' && typeof module.exports != 'undefined') 
                {module.exports = getCaretCoordinates;} else if (isBrowser) {window.getCaretCoordinates = getCaretCoordinates;}}());
                
                let updateVariables = () => {
                    eventBasedVariables = evBaVar[document.getElementById("eventtype").value];
                }

                $("#loadscript").on("change", function (e) {
                    let reader = new FileReader();
                    reader.onload = (function (file) {
                        return function (e) {
                            document.getElementById("scriptarea").value = e.target.result;
                            let scriptNameTiles = file.name.split("-");
                            document.getElementById("eventtype").value = scriptNameTiles.shift();
                            scriptNameTiles = scriptNameTiles.join("-").split(".");
                            scriptNameTiles.pop()
                            document.getElementById("scriptname").value = scriptNameTiles.join(".");
                        };
                    })(this.files[0]);
                    reader.readAsText(this.files[0], "UTF-8");
                });

                for (let ev in evBaVar) {
                    $(`<option value="${ev}">${ev}</option>`).appendTo(document.getElementById("eventtype"))
                }

                $("#eventtype").on("change", function (e) { updateVariables(); });
                updateVariables();
            
                caretHeight = function(){
                    let ta = document.createElement("textarea");
                    document.body.appendChild(ta);
                    ta.value = "\n";
                    let hei = getCaretCoordinates(ta, 1).top - getCaretCoordinates(ta, 0).top;
                    ta.outerHTML = "";
                    return hei;
                }();
            })
        }
        const defaultVars = ["guildid", "guildname", "guildicon", "botid"];
        const userVars = ["userid", "username", "usernick", "userpfp", "discriminator", "usermention"];
        const messageVars = ["content", "messageid", "messageurl", "embedcount", "attachmentcount", "pinned", "tts", "mentionseveryone"];
        const textChannelVars = ["channelid", "channelmention", "channelname", "channeltopic", "categoryid", "nsfw", "slowmode"];
        const voiceChannelVars = ["channelid", "channelmention", "channelname", "categoryid", "bitrate", "userlimit", "connectedusercount"];
        const categoryVars = ["channelid", "channelmention", "channelname", "channelcount"];
        const evBaVar = {
            "onMessage": [].concat(defaultVars).concat(userVars).concat(textChannelVars).concat(messageVars),
            "onJoin": [].concat(defaultVars).concat(userVars),
            "onLeave": [].concat(defaultVars).concat(userVars)
        };

        download = (filename, content) => {
            let element = document.createElement("a");
            element.setAttribute("href", "data:text/plain;charset=utf-8," + encodeURIComponent(content));
            element.setAttribute("download", filename);
            element.style.display = "none";
            document.body.appendChild(element);
            element.click();
            element.outerHTML = "";
        }

        downloadScript = () => {
            download(`${document.getElementById("eventtype").value}-${document.getElementById("scriptname").value}.lbs`, document.getElementById("scriptarea").value);
        }

        escapeHtml = (txt) => {
            return txt.replace(/&/g, "&amp;")
                    .replace(/</g, "&lt;")
                    .replace(/>/g, "&gt;")
                    .replace(/"/g, "&quot;")
                    .replace(/'/g, "&#039;");
        }
        escapeRegex = (txt) => {
            return txt.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
        }
    </script>
    <script src="https://code.jquery.com/jquery-3.4.1.js" integrity="sha256-WpOohJOqMqqyKL9FccASB9O0KwACQJpFTUBLTYOVvVU=" crossorigin="anonymous" onload="init();"></script>
    <style>
        * {
            font-family: Helvetica;
            font-size: 13px;
        }
        html {
            scroll-behavior: smooth;
        }

        #scriptarea {
            width: 100%;
            height: 600px;
            background-color: transparent;
            color: black;
            margin: 0;
            border-radius: 0;
            position: relative;
        }

        #completions {
            position: fixed;
            background-color: #333;
            color: #ddd;
            padding: 5px;
            border-radius: 7px;
            max-height: 200px;
            overflow-y: auto;
        }

        .selected {
            color: red;
        }

        .completeSuggestion {
            margin-right: 30px;
            cursor: default;
        }
        .completeRight, .completeLeft {
            float: right;
            cursor: pointer;
        }
        #container {
            position: relative;
            height: 60%;
            width: 100%;
        }
        #backdrop {
            background-color: #fff;
            overflow: auto;
            position: absolute;
            width: 100%;
            height: 100%;
        }
        #highlights {
            color: transparent;
            white-space: pre-wrap;
            word-wrap: break-word;
            position: absolute;
            left: 3px;
            top: 2px;
        }
        mark {
            color: transparent;
        }
        .highlightFunctionName {
            background-color: yellow;
        }
        .highlightVariableName {
            background-color: rgb(183, 128, 235);
        }
        .highlightVariableMark {
            background-color: hotpink;
        }
        .highlightVariableDeclaration {
            background-color: #aaa;
        }
        .highlightVariableAssignment {
            background-color: red;
        }
        .highlightFunctionArguments {
            background-color: aqua;
        }
        .highlightFunctionArgument {
            background-color: bisque;
        }
        .highlightFunctionQuot {
            background-color: brown;
        }
        .highlightFunctionComma {
            background-color: burlywood;
        }
        .highlightParentheseOpen {
            background-color: cadetblue;
        }
        .highlightParentheseClose {
            background-color: cadetblue;
        }
    </style>
</head>

<body>
    <div>
        To learn how scripts work, read <a href="./scripts.html">the docs</a> about it.<br>
        Here is a short summary:
        <ul>
            <li><code>functionName("argument1", "argument2")</code> calls a function. The number of arguments can be different for each function.</li>
            <li><code>variable=someFunction()</code> saves the return value of the function in <code>variable</code>. To access it again use <code>%variable%</code>.</li>
            <li>There are variables that you can use for each event. They don't have to be defined.</li>
        </ul>
    </div><br>
    Script name: <input id="scriptname"><br>
    Event type: <select id="eventtype"></select><br>
    <div id="container">
        <div id="backdrop"><div id="highlights"></div></div>
        <textarea id="scriptarea"></textarea>
    </div><br>
    <input id="loadscript" type="file">
    <button onclick="downloadScript();">Download Script</button>
</body>

</html>